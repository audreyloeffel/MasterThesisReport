\chapter{Sparse Matrix and Vector in Dl4J}

\section{First COO implementation}

The first implementation of a sparse format was the COO format for vectors and matrices. I used three databuffers to store the array. One for the values, one for the row coordinates and one for the column coordinates.

\subsection{Limitations}
That implementation cannot be extended to n-dimensional array; separate the coordinates into two arrays limits the number of dimension the array can have.
Moreover the implementation of the basic methods was too simple and didn't fit in the interface of the ndarray in Dl4j.

\section{CSR format implementation}

For a generalized version of a sparse representation in dl4j, I choose to use the CSR format. This format has the advantages to consume less memory to store a matrix since one dimension is compresssed and can be directly use with BLAS operations of Intel MKL Sparse BLAS \cite{mklFormat}.

\subsection{?}

\begin{lstlisting}
object {
def main() : Unit = { println(new A().foo(-41)); }
}

class A {
def foo(i : Int) : Int = {
var j : Int;
if(i < 0) { j = 0 - i; } else { j = i; }
return j + 1;
}
}
\end{lstlisting}

\subsection{Adding a value}
\subsection{Retrieve a value}

\subsection{Representation}
\subsection{Operations}
\subsection{Limitations}